# [tochisuke docs](https://tochisuke221.github.io/)

## マテリアライズドビューについて
### 背景
ある処理に制約時間がある場合、発行される各SQLのパフォーマンス自体は悪くなくても、処理全体としての完了時間が要件を満たせないことがある。
このようなケースでは、単純なSQLのパフォーマンスチューニングだけでは改善が難しい。

そのため、処理の事前分割や中間結果のキャッシュといったアプローチが有効となる。
ここでは、そうした手法の代表例であるマテリアライズドビューについて調べる。

また、今回自分の仮説として「一時テーブルをうまく使えば、そのセッション内においてはパフォーマンス改善できるのではないか？」と考え、代表的なアプローチであるマテリアライズドビューと合わせて、テンポラリーテーブルの活用について整理する。

（なお、一時テーブル ≠ CTEである点に注意）

### マテリアライズドビューと一時テーブルについて
#### マテリアライズドビュー

##### 概要
マテリアライズドビューは、SQLクエリの結果を定期的に保存する事前計算ビューのことであり、あたかも通常のテーブルのように結果を保持する。
通常の「ビュー」では、SQL（SELECT文）を保持しているだけなのに対して、マテリアライズドビューはデータの実体を持っている。

また、主な通常のテーブルとの違いは。マテリアライズドビューを**直接更新できない事**である。

マテリアライズドビューを用いると、クエリ結果を保存して各クエリでスキャンされるデータ量を減らすことで、クエリに関連する処理時間と費用を削減できるものの、常に最新のデータを保持しているわけではないことに注意する必要がある。


##### メンテナンス
マテリアライズドビューでは、リフレッシュと呼ばれる管理操作が必要である。 
これは、元表（マスタ表）に加えられた変更をマテリアライズド ビューに反映（同期、メンテナンス）するものである。

PostgreSQLでは、[REFRESHコマンド](https://www.postgresql.jp/document/10/html/sql-refreshmaterializedview.html)が提供されている

```sql
REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] name
```

Oracle等では、[高速REFRESH](http://docs.oracle.com/cd/E57425_01/121/DWHSG/refresh.htm#GUID-4FD1E4C6-B82F-4B13-880C-80187FA22AAF)というログベースに増分だけを更新するコマンドがあり、DBに負荷をかけずに更新することができるがPostgreSQLにおいてはそのようなコマンドが用意されておらず（※1）、再計算が走る。結果、リフレッシュ時には重いクエリ処理が走ってしまうのである。（そもそも重いクエリだから、マテリアライズドビューにしているので）


以上のことから、メンテナンス時には下記のことに気をつけた方が良さそう
- 更新頻度と時間
  - 重い再計算が日中、本番DBに負荷がかかることはなるべく避けておきたい。
- 参照ロック
  - `REFRESH MATERIALIZED VIEWS`コマンドの実行中は対象のビューはロックされる。そのため対象テーブルがどの程度読み書きされるものであるかや、それがユーザに影響するかは考慮しておいた方がよい
  - なお、[CONCURRENTLY](https://www.postgresql.jp/docs/17/sql-refreshmaterializedview.html#:~:text=%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF-,CONCURRENTLY,-%E3%81%9D%E3%81%AE%E3%83%9E%E3%83%86%E3%83%AA%E3%82%A2)オプションで回避することもできる
    - ただし、下記の制約がある
      - UNIQUEインデックスが必要
        - 通常の REFRESH は「全削除＋全再計算」であるのに対し、CONCURRENTLY は「差分検出＋差分反映」を行う。この差分判定には、すべての行を識別できる UNIQUEインデックスが必要である。
        - 一時テーブルを作るため、work_memを多く使うことに注意が必要
      - すでにデータが存在している必要がある
        - REFRESH MATERIALIZED VIEW CONCURRENTLY は、空のマテビューには使えません。
      - 同時に1つしか実行できない
        - 同じマテビューに対して、複数の CONCURRENTLY リフレッシュは同時に走りません。つまり「同時に実行できるのは1プロセスまで」。

※1: 現在開発中らしい（https://www.sraoss.co.jp/tech-blog/pgsql/postgresql_ivm/）


##### ストレージについて
PostgreSQLはマテリアライズドビューに対して、クエリ結果をテーブルと同じような形で保存します。
そのため、保存先として以下のような構造が作られます
- データブロック（ヒープ）
- TOAST領域（大きいテキスト等の圧縮）
- インデックス（必要に応じて）

つまり、物理的なディスク領域を使うという点で、ふつうのテーブルと変わりません。

よって、元データの増加に対して、マテビューの行数やデータ量が**加速度的に増加**する設計になっている場合、ストレージ圧迫に注意が必要である。



#### TEMPORARY TABLE（一時テーブル）
##### 概要
PostgreSQLのTEMPORARY TABLE(一時テーブル)は接続したセッションの間にしか生存できないテーブルのこと。
このテーブルは他のセッションからはアクセスすることができないテーブル。

作成後セッションが継続している間は通常のテーブルと同様に使えますが、セッションが終わると自動で削除されます。
セッション終了時だけでなく、トランザクション終了時に消したりも出来ます。

通常のテーブルであれば共有バッファを使用してテーブルを読み込むが、一時テーブルはサーバープロセスがもつ[tmp_buffer](https://www.postgresql.jp/docs/11/runtime-config-resource.html)で管理される

<img src="../2025-07-12-postgresql-architecture/postgre.png">

なお、Railsにおいては ActiveRecord に一時テーブル用のDSLは存在しないため、明示的に SQL を発行する必要がある。

また一時テーブルは、DBによっても挙動が微妙に異なるため注意が必要になる。

###### メンテナス
一時テーブルによる実装は、アプリケーションコードの変更のみに完結するため比較的容易に行える。
また、セッション終了ともに削除されるため、特別メンテナンス等を必要としない。

##### ストレージ
[https://dev.to/crushby/postgresql-and-temporary-tables-1ned](https://dev.to/crushby/postgresql-and-temporary-tables-1ned)の記事にある通り、一時テーブルはディスクに実ファイルを作成する（例：base/pgsql_tmp/ PostgreSQLの一時テーブル（TEMP TABLE）は、通常のテーブルと同様にディスク上に実ファイルが作成される仕組みになっており、例えば base/pgsql_tmp/ や base/{db_oid}/ などに格納される。

CREATE TEMP TABLE を実行するたびに新しい物理ファイル（relfilenode）が割り当てられ、TRUNCATE 時もファイルが差し替えられるため、ファイルの作成・削除が頻繁に発生する。この挙動により、ext4 や xfs といったファイルシステムでは、1ディレクトリ内に多数のファイルが集中しやすく、ディスク I/O の増加や OS レベルのバッファローテーションによる負荷増大が懸念される。

さらに、PostgreSQLでは一時テーブルに対してもMVCC（Multi-Version Concurrency Control）が適用されており、トランザクション中の INSERT / UPDATE / DELETE に対しては通常のテーブルと同様にUNDO情報（旧バージョン）を保持する設計になっている。これにより、ロールバックが可能となるが、実際のユースケースでは「一時テーブルは失敗しても構わない」という性質を持つ処理が多く、整合性の高さがかえって過剰となるケースもある。

一時テーブルにはWAL（Write-Ahead Logging）は適用されないが、内部的には一部でWALバッファが使われたり、MVCCのためのヒープ管理が走る。そのため、セッション内の一時的なデータ処理にもかかわらず、WALバッファの確保やトランザクションログ管理、ヒープ構造の維持といった処理が発生し、意外と重くなることがある。これらの要因が重なると、アプリケーションの意図以上にPostgreSQLの内部負荷が高まる可能性があるため、性能要件や規模に応じて使用可否を検討すべきである。


## マテリアライズドビューと一時テーブルの使い分け
パフォーマンス改善のために中間結果をキャッシュする手段として、マテリアライズドビューと一時テーブルの2つが考えられるが、
用途や運用の観点から明確な使い分けが必要である。

個人的には、安定運用・再現性・可観測性の観点から、マテリアライズドビューの方が本番環境での運用に向いていると感じている。
特に以下のようなケースではマテビューが有効だと考えられる：

- 重いクエリの結果を定期的にキャッシュしておきたい
- 集計バッチ処理の基盤として中間集計結果を保持したい
- 一定期間、中間結果を確認できる状況を作っておきたい
- スナップショットをもとに異常検知や差分検出を行いたい

マテビューは REFRESH されるまでは中身が更新されないため、**「特定時点のスナップショットを複数のプロセスで安全に共有できる」**という強みがある。運用中のデバッグや障害時の調査、トレーサビリティの確保にも活用できる点は、単なるパフォーマンス改善以上の価値がある。

一方、一時テーブルはそのセッション中に閉じた一時的な中間結果の保持には適しており、下記のようなユースケースで活躍する

- アプリケーションコード内で一時的にデータを集計し、そのまま次のクエリに使いたい（例：N+1回避）
- 大量の副問い合わせをバッチで処理する際、JOIN先を一時表にまとめておきたい
- WITH句では記述が難しい、複数ステップにまたがる処理を構造的に切り出したい

ただし、PostgreSQLにおいて一時テーブルはディスクI/Oやシステムカタログ（pg_class等）への負荷、MVCCによる厳密な管理など、一見軽量に見えて実際にはそれなりに重たい処理が裏で動く点には留意が必要である。

以上を踏まえると、「再利用性・共有性・検証性が必要なケースではマテビュー」、**「その場限りのワーク領域として軽く使いたい場合は一時テーブル」**という棲み分けが実践的であると考える。

## マテビューのRailsでの実装方法
ここからはRailsでマテビューを実装するには、DSL、マイグレーション、rake scenic:refresh など手堅くまとまっている[scenic](https://github.com/scenic-views/scenic)というgemが有用そうである。というより、これがデファクトスタンダードになっているようにも見える。

https://pganalyze.com/blog/materialized-views-ruby-rails の記事が使い方等わかりやすいが、gem本体のREADMEも非常にわかりやすいので、ぜひ参考にしてみると良い


## 参考
  - [PostgreSQLのドキュメント](https://www.postgresql.jp/docs/17/rules-materializedviews.html)
  - [BigQueryのドキュメント](https://cloud.google.com/bigquery/docs/materialized-views-intro?hl=ja)
  - [[PostgreSQL]複雑なクエリや集計処理に対する参照のパフォーマンスを向上させることのできるマテリアライズドビューについてまとめてみた](https://www.sraoss.co.jp/tech-blog/pgsql/postgresql_ivm/)
  - [TEMPORARY TABLE（一時テーブル）を探る](https://qiita.com/noborus/items/16ea90339a637d0f40f7)
